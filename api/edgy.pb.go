// Code generated by protoc-gen-go.
// source: edgy.proto
// DO NOT EDIT!

/*
Package api is a generated protocol buffer package.

It is generated from these files:
	edgy.proto

It has these top-level messages:
	PingRequest
	PingReply
	OffsetData
	AppendRequest
	ReadReply
	ReadRequest
	AppendReply
*/
package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type PingRequest struct {
}

func (m *PingRequest) Reset()         { *m = PingRequest{} }
func (m *PingRequest) String() string { return proto.CompactTextString(m) }
func (*PingRequest) ProtoMessage()    {}

type PingReply struct {
}

func (m *PingReply) Reset()         { *m = PingReply{} }
func (m *PingReply) String() string { return proto.CompactTextString(m) }
func (*PingReply) ProtoMessage()    {}

type OffsetData struct {
	MessageId   uint64 `protobuf:"varint,1,opt,name=message_id" json:"message_id,omitempty"`
	EndPosition int64  `protobuf:"varint,2,opt,name=end_position" json:"end_position,omitempty"`
	SegmentId   uint64 `protobuf:"varint,3,opt,name=segment_id" json:"segment_id,omitempty"`
}

func (m *OffsetData) Reset()         { *m = OffsetData{} }
func (m *OffsetData) String() string { return proto.CompactTextString(m) }
func (*OffsetData) ProtoMessage()    {}

type AppendRequest struct {
	Topic     string `protobuf:"bytes,1,opt,name=topic" json:"topic,omitempty"`
	Partition int32  `protobuf:"varint,2,opt,name=partition" json:"partition,omitempty"`
	Messages  []byte `protobuf:"bytes,3,opt,name=messages,proto3" json:"messages,omitempty"`
}

func (m *AppendRequest) Reset()         { *m = AppendRequest{} }
func (m *AppendRequest) String() string { return proto.CompactTextString(m) }
func (*AppendRequest) ProtoMessage()    {}

type ReadReply struct {
	Messages []byte      `protobuf:"bytes,1,opt,name=messages,proto3" json:"messages,omitempty"`
	Offset   *OffsetData `protobuf:"bytes,2,opt,name=offset" json:"offset,omitempty"`
}

func (m *ReadReply) Reset()         { *m = ReadReply{} }
func (m *ReadReply) String() string { return proto.CompactTextString(m) }
func (*ReadReply) ProtoMessage()    {}

func (m *ReadReply) GetOffset() *OffsetData {
	if m != nil {
		return m.Offset
	}
	return nil
}

type ReadRequest struct {
	Topic      string      `protobuf:"bytes,1,opt,name=topic" json:"topic,omitempty"`
	Partition  int32       `protobuf:"varint,2,opt,name=partition" json:"partition,omitempty"`
	Offset     *OffsetData `protobuf:"bytes,3,opt,name=offset" json:"offset,omitempty"`
	Continuous bool        `protobuf:"varint,4,opt,name=continuous" json:"continuous,omitempty"`
}

func (m *ReadRequest) Reset()         { *m = ReadRequest{} }
func (m *ReadRequest) String() string { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()    {}

func (m *ReadRequest) GetOffset() *OffsetData {
	if m != nil {
		return m.Offset
	}
	return nil
}

type AppendReply struct {
	Ok bool `protobuf:"varint,1,opt,name=ok" json:"ok,omitempty"`
}

func (m *AppendReply) Reset()         { *m = AppendReply{} }
func (m *AppendReply) String() string { return proto.CompactTextString(m) }
func (*AppendReply) ProtoMessage()    {}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Edgy service

type EdgyClient interface {
	Append(ctx context.Context, in *AppendRequest, opts ...grpc.CallOption) (*AppendReply, error)
	Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (Edgy_ReadClient, error)
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingReply, error)
}

type edgyClient struct {
	cc *grpc.ClientConn
}

func NewEdgyClient(cc *grpc.ClientConn) EdgyClient {
	return &edgyClient{cc}
}

func (c *edgyClient) Append(ctx context.Context, in *AppendRequest, opts ...grpc.CallOption) (*AppendReply, error) {
	out := new(AppendReply)
	err := grpc.Invoke(ctx, "/api.Edgy/Append", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *edgyClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (Edgy_ReadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Edgy_serviceDesc.Streams[0], c.cc, "/api.Edgy/Read", opts...)
	if err != nil {
		return nil, err
	}
	x := &edgyReadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Edgy_ReadClient interface {
	Recv() (*ReadReply, error)
	grpc.ClientStream
}

type edgyReadClient struct {
	grpc.ClientStream
}

func (x *edgyReadClient) Recv() (*ReadReply, error) {
	m := new(ReadReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *edgyClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingReply, error) {
	out := new(PingReply)
	err := grpc.Invoke(ctx, "/api.Edgy/Ping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Edgy service

type EdgyServer interface {
	Append(context.Context, *AppendRequest) (*AppendReply, error)
	Read(*ReadRequest, Edgy_ReadServer) error
	Ping(context.Context, *PingRequest) (*PingReply, error)
}

func RegisterEdgyServer(s *grpc.Server, srv EdgyServer) {
	s.RegisterService(&_Edgy_serviceDesc, srv)
}

func _Edgy_Append_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(AppendRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(EdgyServer).Append(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Edgy_Read_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EdgyServer).Read(m, &edgyReadServer{stream})
}

type Edgy_ReadServer interface {
	Send(*ReadReply) error
	grpc.ServerStream
}

type edgyReadServer struct {
	grpc.ServerStream
}

func (x *edgyReadServer) Send(m *ReadReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Edgy_Ping_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(PingRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(EdgyServer).Ping(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Edgy_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Edgy",
	HandlerType: (*EdgyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Append",
			Handler:    _Edgy_Append_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Edgy_Ping_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Read",
			Handler:       _Edgy_Read_Handler,
			ServerStreams: true,
		},
	},
}
